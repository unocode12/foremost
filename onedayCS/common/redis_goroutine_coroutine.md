# Redis vs Go Goroutine vs Python Coroutine

## 0.한 눈에 보는 요약 비교

  -------------------------------------------------------------------------
  구분              Redis               Go Goroutine      Python Coroutine
  ----------------- ------------------- ----------------- -----------------
  실행 모델         싱글 스레드 이벤트  M:N 스케줄링      싱글 스레드
                    루프                                  이벤트 루프

  동시성 방식       이벤트 기반 직렬    병렬 + 동시성     협력적 동시성
                    처리                                  

  스케줄러          Redis 내부 이벤트   Go 런타임         asyncio 이벤트
                    루프                                  루프

  CPU 병렬성        ❌                  ✅                ❌

  내부 큐           클라이언트/이벤트   Run Queue         Ready Queue
                    큐                                    

  블로킹 처리       블로킹 시 전체 지연 블로킹            블로킹 시 전체
                                        goroutine만 대기  지연
  -------------------------------------------------------------------------

## 1. 먼저 공통 개념부터: 실행 단위와 스케줄링

### 실행 단위란?

-   CPU에서 "실제로 돌아가야 할 일"
-   예:
    -   Redis: 명령 처리
    -   Python: coroutine(Task)
    -   Go: goroutine

### 스케줄링이란?

-   여러 실행 단위를
-   제한된 CPU 코어에
-   언제, 어떤 순서로 올릴지 정하는 것

------------------------------------------------------------------------

## 2. Redis 동작 방식 (가장 단순)

### 핵심 요약

-   **스레드 1개**
-   **이벤트 루프 1개**
-   **명령은 무조건 하나씩 처리**

```{=html}
<!-- -->
```
    [이벤트 루프]
       ↓
    요청 읽기 → 명령 실행 → 응답 쓰기

### 중요한 의미

-   동시에 여러 클라이언트가 와도
-   "처리는 항상 한 줄로 서서" 함
-   하나가 오래 걸리면 전부 대기

👉 Redis는 빠른 이유가 **단순함**

------------------------------------------------------------------------

## 3. Python Coroutine (asyncio)

### 핵심 요약

-   **스레드 1개**
-   **이벤트 루프 1개**
-   **await에서만 양보**

```{=html}
<!-- -->
```
    Coroutine 실행
       ↓
    await → 이벤트 루프 반환
       ↓
    다른 coroutine 실행

### 왜 await가 중요할까?

-   await 안 하면:
    -   이벤트 루프가 다른 일을 못 함
    -   전체 서비스가 멈춘 것처럼 보임

👉 Python async는 **착한 코루틴**이 전제

------------------------------------------------------------------------

## 4. Go Goroutine

### 핵심 요약

-   goroutine은 스레드가 아님
-   Go 런타임이 관리
-   수십만 개 생성 가능

------------------------------------------------------------------------

## 5. G-P-M 모델 쉽게 설명

  구성            비유
  --------------- --------
  G (goroutine)   일감
  P (processor)   작업대
  M (OS thread)   작업자

-   작업대(P)가 있어야 작업자(M)가 일감을 처리 가능
-   작업대 개수 = 동시에 실행 가능한 개수
-   “고루틴 스케줄링은 Go 런타임이 하고, P는 런타임이 스케줄링하기 위해 사용하는 실행 컨텍스트다”

------------------------------------------------------------------------

## 6. 그럼 M:N 스케줄링이란?

### 한 줄 정의

> **N개의 goroutine을 M개의 OS 스레드에 나눠서 실행하는 구조**

### 그림으로 보면

    goroutine 100,000개
            ↓
    Go Runtime Scheduler
            ↓
    OS Thread 8개
            ↓
    CPU Core 8개

-   goroutine 수(N)는 많고
-   OS 스레드 수(M)는 적다
-   런타임이 중간에서 계속 교통정리

👉 이걸 **M:N 스케줄링**이라 부름

------------------------------------------------------------------------

## 7. Python / Redis는 왜 M:N이 아닐까?

### Redis

-   실행 단위 = 명령
-   스레드 1개
-   이벤트 루프 1개

→ **1:1에 가까움**

### Python asyncio

-   coroutine은 많지만
-   실행은 스레드 1개

→ 구조적으로 **1:N 처럼 보이지만 실제 실행은 1:1**

------------------------------------------------------------------------

## 8. Go만 M:N인 이유

-   Go 런타임이:
    -   goroutine 생성
    -   run queue 관리
    -   work stealing
    -   블로킹 분리 를 전부 직접 처리

👉 운영체제 스케줄러에 덜 의존

------------------------------------------------------------------------

## 9. 큐(run queue)가 왜 중요한가?

  시스템   큐 의미
  -------- --------------------------
  Redis    처리할 클라이언트 목록
  Python   실행 재개 대기 coroutine
  Go       CPU에 올릴 goroutine

-   Go는 큐를 적극적으로 사용해
-   CPU 활용률을 높임

------------------------------------------------------------------------

## 10. 한 문장 요약

-   Redis: **한 줄로 빠르게 처리**
-   Python async: **await로 질서 유지**
-   Go: **런타임이 교통정리하며 병렬 실행**

------------------------------------------------------------------------

## 11. 진짜 중요한 결론

> M:N 스케줄링이란\
> **"많은 가벼운 작업을, 적은 무거운 스레드로 효율적으로 굴리는
> 방식"**이다.

이게 Go가 서버에서 강한 이유다.
